package com.thirdsense.animation 
{
	import com.thirdsense.LaunchPad;
	import com.thirdsense.utils.Trig;
	import flash.display.Bitmap;
	import flash.display.BitmapData;
	import flash.display.MovieClip;
	import flash.display.Sprite;
	import flash.events.MouseEvent;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.utils.setTimeout;
	import starling.utils.getNextPowerOfTwo;
	
	/**
	 * Class to enable consolidation of SpriteSequence objects in to a single size optimized spritesheet for use with Starling
	 * @author Ben Leffler
	 */
	
	public class SpriteSheetHelper 
	{
		/**
		 * Resulting spritesheet generated by the consolidateSprites static function
		 */
		public var spritesheet:BitmapData;
		
		/**
		 * Resulting sparrow xml generated by the consolidateSprites static function
		 */
		public var sparrow_xml:XML;
		
		/**
		 * The pool name of the object
		 */
		public var pool:String;
		
		/**
		 * Vector of participating SpriteSequence objects
		 */
		public var sprite_sequences:Vector.<SpriteSequence>;
		
		/**
		 * constructor
		 */
		public function SpriteSheetHelper() 
		{
			
		}
		
		/**
		 * Obtains an array of the available sequence names contained within the helper object
		 */
		
		public function get sequences():Array
		{
			var arr:Array = new Array();
			for ( var i:uint = 0; i < this.sprite_sequences.length; i++ )
			{
				arr.push( this.sprite_sequences[i].sequence );
			}
			return arr;
		}
		
		/**
		 * Obtains the offset point associated with a specific SpriteSequence contained within the helper
		 * @param	sequence_name	The name of the sequence to obtain an offset for
		 * @return	Point representation of the offset
		 */
		
		public function getOffset( sequence_name:String ):Point
		{
			for ( var i:uint = 0; i < this.sprite_sequences.length; i++ )
			{
				if ( this.sprite_sequences[i].sequence == sequence_name )
				{
					return this.sprite_sequences[i].cell_offset;
				}
			}
			
			return null;
		}
		
		/**
		 * Disposes BitmapData objects contained within associated SpriteSequences and the resulting spritesheet object
		 */
		
		public function dispose():void
		{
			if ( this.sprite_sequences && this.sprite_sequences.length )
			{
				for ( var i:uint = 0; i < this.sprite_sequences.length; i++ )
				{
					this.sprite_sequences[i].dispose();
				}
			}
			
			if ( this.spritesheet )
			{
				this.spritesheet.dispose();
				this.spritesheet = null;
			}
		}
		
		/**
		 * Arranges a vector of rectangle objects in to an optimal format that adheres to a Base-2 spritesheet layout
		 * @param	rects	An array of Rectangles to be arranged. The objects contained within will be directly translated.
		 * @return	The optimal base-2 value the arrangement has configured
		 */
		
		static public function arrange( rects:Vector.<Rectangle> ):int
		{
			// As per Richard E. Korf's paper: Optimal Rectangle Packing: Initial Results - http://www.aaai.org/Papers/ICAPS/2003/ICAPS03-029.pdf
			// 1
			
			// clone the rectangle vector and sort in order of area (large > small)
			var rectangles:Vector.<Rectangle> = new Vector.<Rectangle>;
			for ( var k:uint = 0; k < rects.length; k++ )
			{
				rectangles.push( rects[k] );
			}
			rectangles.sort( sortFn );
			
			// 3
			// staring with an area of Base2 area of 2, tries to fit all rectangles within said area. When it fails, increase the area by
			// next power of two... and so on until all rectangles fit
			var success:Boolean = false;
			var pw2:int = 2;
			
			while ( !success )
			{
				success = true;
				
				var envelope:Rectangle = new Rectangle( 0, 0, pw2, pw2 );
				var placed:Boolean = false;
				
				// first check if all rectangles don't exceed the envelope area. If so, instant fail then on to next power of two size up
				var len:int = rectangles.length;
				for ( var i:uint = 0; i < len; i++ )
				{
					if ( rectangles[i].width > pw2 || rectangles[i].height > pw2 )
					{
						success = false;
						break;
					}
				}
				
				// Each rectangle can individually fit in the envelope. Now try to arrange ALL rectangles to fit within the envelope, whilst
				// not overlapping with each other.
				if ( success )
				{
					for ( i = 0; i < len; i++ )
					{
						// Checks EVERY pixel position in the envelope for a fit
						
						var lim_x:Number = pw2 - rectangles[i].width;
						var lim_y:Number = pw2 - rectangles[i].height;
						
						for ( var x1:int = 0; x1 <= lim_x; x1++ )
						{
							placed = false;
							
							for ( var y1:int = 0; y1 <= lim_y; y1++ )
							{
								rectangles[i].x = x1;
								rectangles[i].y = y1;
								
								// check collision with other rectangles. If colliding, break and try the next pixel position
								var collides:Boolean = false;
								for ( var j:uint = 0; j < i; j++ )
								{
									if ( rectangles[i].intersects(rectangles[j]) )
									{
										collides = true;
									}
								}
								
								// The rectangle doesn't collide with others, so check if it is within the bounds of the envelope area
								if ( !collides && envelope.containsRect(rectangles[i]) )
								{
									placed = true;
									break;
								}
							}
							
							if ( placed )
							{
								break;
							}
						}
						
						
						if ( !placed )
						{
							success = false;
							break;
						}
					}
				}
				
				if ( !success ) pw2 = getNextPowerOfTwo( pw2 + 1 );				
			}
			
			return pw2;
			
		}
		
		/**
		 * @private	Sorts based on a criteria of rectangle area and then rectangle width
		 * @param	rect1
		 * @param	rect2
		 * @return
		 */
		
		static private function sortFn( rect1:Rectangle, rect2:Rectangle ):int
		{
			if ( rect1.width * rect1.height > rect2.width * rect2.height ) return -1;
			if ( rect1.width * rect1.height < rect2.width * rect2.height ) return 1;
			
			if ( rect1.width > rect2.width ) return -1;
			if ( rect1.width < rect2.width ) return 1;
			
			return 0;
		}
		
		/**
		 * Takes an array of SpriteSequence objects, packages them up and creates a SpriteSheetHelper object for optimized use in Starling
		 * @param	sequences	An array of SpriteSequence objects. These objects should have a common pool parameter and contain unique sequence names for identification purposes
		 * @return	A new SpriteSheetHelper object for use with the LaunchPad TexturePack class
		 */
		
		static public function consolidateSprites( sequences:Array ):SpriteSheetHelper
		{
			var len:int = sequences.length;
			var rects:Vector.<Rectangle> = new Vector.<Rectangle>;
			var bmds:Vector.<BitmapData> = new Vector.<BitmapData>;
			var names:Array = new Array();
			var offsets:Object = new Object();
			
			for ( var i:uint = 0; i < len; i++ )
			{
				var ss:SpriteSequence = sequences[i];
				for ( var j:uint = 0; j < ss.sprites.length; j++ )
				{
					rects.push( ss.sprites[j].rect );
					bmds.push( ss.sprites[j] );
					names.push( ss.sequence );
				}
				offsets[ ss.sequence ] = ss.cell_offset;
			}
			
			var pw2:int = arrange( rects );
			
			var sheet:BitmapData = new BitmapData( pw2, pw2, true, 0 );
			var pt:Point = new Point();
			len = rects.length;
			for ( i = 0; i < len; i++ )
			{
				pt.x = rects[i].x;
				pt.y = rects[i].y;
				sheet.copyPixels( bmds[i], bmds[i].rect, pt, null, null, true );
			}
			
			var ssh:SpriteSheetHelper = new SpriteSheetHelper();
			ssh.pool = sequences[0].pool;
			ssh.spritesheet = sheet;
			ssh.sprite_sequences = new Vector.<SpriteSequence>;
			for ( i = 0; i < sequences.length; i++ )
			{
				ssh.sprite_sequences.push( sequences[i] );
			}
			
			var str:String = "<TextureAtlas imagePath=''>";
			var prefix:String = "";
			for ( i = 0; i < len; i++ )
			{
				prefix += "a";
				str += "<SubTexture name='" + names[i] + "_" + prefix + "' x='" + rects[i].x + "' y='" + rects[i].y + "' width='" + rects[i].width + "' height='" + rects[i].height + "' />";
				if ( ssh.sequences.indexOf(names[i]) < 0 ) ssh.sequences.push( names[i] );
			}
			str += "</TextureAtlas>";
			ssh.sparrow_xml = new XML(str);
			
			return ssh;
			
		}
		
	}

}